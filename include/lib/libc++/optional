/**
 * @author Jayden Grubb (contact@jaydengrubb.com)
 * @date 2023-07-31
 * @brief Class template for objects that may or may not contain a value
 * @link https://en.cppreference.com/w/cpp/utility/optional @endlink
 *
 * Copyright (c) 2023, Jayden Grubb
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree.
 */

#pragma once

#ifdef __is_kernel
#include <kernel/arch/cpu.h>
#include <kernel/debug.h>
#endif

// TODO add __needs_std_move
// TODO add __needs_std_forward
// TODO add __needs_std_swap
// TODO add __needs_std_in_place
#include <lib/libc++/utility>

#include <initializer_list>
#include <type_traits>

// TODO check trivially *** constructors and operators

namespace std {
	/**
	 * @brief Tag type used to indicate an empty optional
	 *
	 */
	struct nullopt_t {
		enum class _construct { _token };
		explicit constexpr nullopt_t(_construct) noexcept {}
	};

	/**
	 * @brief Constant of type nullopt_t that is used to indicate an empty optional
	 *
	 */
	inline constexpr nullopt_t nullopt{nullopt_t::_construct::_token};

	template <typename>
	class optional;

	/**
	 * @brief Class template for objects that may or may not contain a value
	 *
	 * @tparam T The type of the value to be stored
	 */
	template <typename T>
	class optional {
		static_assert(!is_same_v<remove_cv_t<T>, nullopt_t>);
		static_assert(!is_same_v<remove_cv_t<T>, in_place_t>);
		static_assert(!is_reference_v<T>);

	  private:
		bool _has_value;
		T _value;

		template <typename U>
		friend class optional;

	  public:
		/**
		 * @brief Construct a new optional object
		 *
		 * @link https://en.cppreference.com/w/cpp/utility/optional/optional @endlink
		 */
		constexpr optional() noexcept
			: _has_value(false) {}

		/**
		 * @brief Construct a new optional object
		 *
		 * @link https://en.cppreference.com/w/cpp/utility/optional/optional @endlink
		 */
		constexpr optional(nullopt_t) noexcept
			: _has_value(false) {}

		/**
		 * @brief Construct a new optional object
		 *
		 * @param other The optional object to construct from
		 *
		 * @link https://en.cppreference.com/w/cpp/utility/optional/optional @endlink
		 */
		constexpr optional(const optional &other)
			requires(is_copy_constructible_v<T>)
			: _has_value(other._has_value) {
			if (other._has_value) {
				new (&_value) T(other._value);
			}
		}

		/**
		 * @brief Construct a new optional object
		 *
		 * @param other The optional object to construct from
		 *
		 * @link https://en.cppreference.com/w/cpp/utility/optional/optional @endlink
		 */
		constexpr optional(optional &&other) noexcept(is_nothrow_copy_constructible_v<T>)
			requires(is_move_constructible_v<T>)
			: _has_value(other._has_value) {
			if (other._has_value) {
				new (&_value) T(move(other._value));
			}
		}
		// VERIFY noexcept is meaningless with exceptions disabled

		/**
		 * @brief Construct a new optional object
		 *
		 * @tparam T The type of the value to be stored
		 * @tparam U The type of the object to construct from
		 * @param other The optional object to construct from
		 *
		 * @link https://en.cppreference.com/w/cpp/utility/optional/optional @endlink
		 */
		template <typename U>
		constexpr explicit(!is_convertible_v<const U &, T>) optional(const optional<U> &other)
			requires(is_constructible_v<T, const U &>)
			: _has_value(other._has_value) {
			if (other._has_value) {
				new (&_value) T(other._value);
			}
		}

		/**
		 * @brief Construct a new optional object
		 *
		 * @tparam T The type of the value to be stored
		 * @tparam U The type of the object to construct from
		 * @param other The optional object to construct from
		 *
		 * @link https://en.cppreference.com/w/cpp/utility/optional/optional @endlink
		 */
		template <typename U>
		constexpr explicit(!is_convertible_v<U &&, T>) optional(optional<U> &&other)
			: _has_value(other._has_value) {
			if (other._has_value) {
				new (&_value) T(move(other._value));
			}
		}

		/**
		 * @brief Construct a new optional object
		 *
		 * @tparam Args The types of the arguments to be passed to the constructor of T
		 * @param args The arguments to be passed to the constructor of T
		 *
		 * @link https://en.cppreference.com/w/cpp/utility/optional/optional @endlink
		 */
		template <typename... Args>
		constexpr explicit optional(in_place_t, Args &&...args)
			requires(is_constructible_v<T, Args...>)
			: _has_value(true), _value(forward<Args>(args)...) {}

		/**
		 * @brief Construct a new optional object
		 *
		 * @tparam U The type of the value to be stored
		 * @tparam Args The types of the arguments to be passed to the constructor of T
		 * @param list The initializer list to be passed to the constructor of T
		 * @param args The arguments to be passed to the constructor of T
		 *
		 * @link https://en.cppreference.com/w/cpp/utility/optional/optional @endlink
		 */
		template <typename U, typename... Args>
		constexpr explicit optional(in_place_t, initializer_list<U> list, Args &&...args)
			requires(is_constructible_v<T, initializer_list<U> &, Args...>)
			: _has_value(true), _value(list, forward<Args>(args)...) {}

		/**
		 * @brief Construct a new optional object
		 *
		 * @tparam U The type of the value to be stored
		 * @param value The value to be stored
		 *
		 * @link https://en.cppreference.com/w/cpp/utility/optional/optional @endlink
		 */
		template <typename U = T>
		constexpr explicit(!is_convertible_v<U &&, T>) optional(U &&value)
			requires(is_constructible_v<T, U &&> &&
					 !is_same_v<remove_cv_t<U>, in_place_t> &&
					 !is_same_v<remove_cv_t<U>, optional<T>>)
			: _has_value(true), _value(forward<U>(value)) {}

		/**
		 * @brief Destroy the optional object
		 *
		 * @link https://en.cppreference.com/w/cpp/utility/optional/~optional @endlink
		 */
		constexpr ~optional()
			requires(!is_trivially_destructible_v<T>)
		{
			if (_has_value) {
				_value.~T();
			}
		}

		/**
		 * @brief Destroy the optional object
		 *
		 * @link https://en.cppreference.com/w/cpp/utility/optional/~optional @endlink
		 */
		constexpr ~optional()
			requires(is_trivially_destructible_v<T>)
		= default;

		/**
		 * @brief Assigns a new value to the optional object
		 *
		 * @return The optional object
		 *
		 * @link https://en.cppreference.com/w/cpp/utility/optional/operator%3D @endlink
		 */
		constexpr optional &operator=(nullopt_t) noexcept {
			if (_has_value) {
				_value.~T();
				_has_value = false;
			}
			return *this;
		}

		/**
		 * @brief Assigns a new value to the optional object
		 *
		 * @param other The optional object to assign from
		 * @return The optional object
		 *
		 * @link https://en.cppreference.com/w/cpp/utility/optional/operator%3D @endlink
		 */
		constexpr optional &operator=(const optional &other)
			requires(is_copy_constructible_v<T> && is_copy_assignable_v<T>)
		{
			if (_has_value && !other._has_value) {
				_value.~T();
			} else if (other._has_value) {
				if (_has_value) {
					_value = other._value;
				} else {
					new (&_value) T(other._value);
				}
			}
			_has_value = other._has_value;
			return *this;
		}

		/**
		 * @brief Assigns a new value to the optional object
		 *
		 * @param other The optional object to assign from
		 * @return The optional object
		 *
		 * @link https://en.cppreference.com/w/cpp/utility/optional/operator%3D @endlink
		 */
		constexpr optional &operator=(optional &&other) noexcept(is_nothrow_move_assignable_v<T> &&is_nothrow_move_constructible_v<T>)
			requires(is_move_constructible_v<T> && is_move_assignable_v<T>)
		{
			if (_has_value && !other._has_value) {
				_value.~T();
			} else if (other._has_value) {
				if (_has_value) {
					_value = move(other._value);
				} else {
					new (&_value) T(move(other._value));
				}
			}
			_has_value = other._has_value;
			return *this;
		}
		// VERIFY noexcept is meaningless without exceptions enabled

		/**
		 * @brief Assigns a new value to the optional object
		 *
		 * @tparam U The type of the value to be stored
		 * @param value The value to be stored
		 *
		 * @link https://en.cppreference.com/w/cpp/utility/optional/operator%3D @endlink
		 */
		template <typename U = T>
		constexpr optional &operator=(U &&value)
			requires(!is_same_v<remove_cvref_t<U>, optional<T>> &&
					 is_assignable_v<T &, U> &&
					 is_constructible_v<T, U> &&
					 (!is_scalar_v<T> || !is_same_v<T, decay_t<U>>))
		{
			_has_value = true;
			if (_has_value) {
				_value = forward<U>(value);
			} else {
				new (&_value) T(forward<U>(value));
			}
			return *this;
		}

		/**
		 * @brief Assigns a new value to the optional object
		 *
		 * @tparam U The type of the value to be stored
		 * @param other The optional object to assign from
		 *
		 * @link https://en.cppreference.com/w/cpp/utility/optional/operator%3D @endlink
		 */
		template <typename U>
		constexpr optional &operator=(const optional<U> &other)
			requires(is_constructible_v<T, const U &> && is_assignable_v<T &, const U &>)
		{
			if (_has_value && !other._has_value) {
				_value.~T();
			} else if (other._has_value) {
				if (_has_value) {
					_value = other._value;
				} else {
					new (&_value) T(other._value);
				}
			}
			_has_value = other._has_value;
			return *this;
		}

		/**
		 * @brief Assigns a new value to the optional object
		 *
		 * @tparam U The type of the value to be stored
		 * @param other The optional object to assign from
		 *
		 * @link https://en.cppreference.com/w/cpp/utility/optional/operator%3D @endlink
		 */
		template <typename U>
		constexpr optional &operator=(optional<U> &&other)
			requires(is_constructible_v<T, U> && is_assignable_v<T &, U>)
		{
			if (_has_value && !other._has_value) {
				_value.~T();
			} else if (other._has_value) {
				if (_has_value) {
					_value = move(other._value);
				} else {
					new (&_value) T(move(other._value));
				}
			}
			_has_value = other._has_value;
			return *this;
		}

		/**
		 * @brief Checks if the optional object has a value
		 *
		 * @return true if the optional object has a value
		 *
		 * @link https://en.cppreference.com/w/cpp/utility/optional/operator_bool @endlink
		 */
		constexpr explicit operator bool() const noexcept {
			return _has_value;
		}

		/**
		 * @brief Checks if the optional object has a value
		 *
		 * @return true if the optional object has a value
		 *
		 * @link https://en.cppreference.com/w/cpp/utility/optional/operator_bool @endlink
		 */
		constexpr bool has_value() const noexcept {
			return _has_value;
		}

		/**
		 * @brief Returns a pointer to the value
		 *
		 * @return A pointer to the value
		 *
		 * @link https://en.cppreference.com/w/cpp/utility/optional/operator* @endlink
		 */
		constexpr const T *operator->() const noexcept {
			return &_value;
		}

		/**
		 * @brief Returns a pointer to the value
		 *
		 * @return A pointer to the value
		 *
		 * @link https://en.cppreference.com/w/cpp/utility/optional/operator* @endlink
		 */
		constexpr T *operator->() noexcept {
			return &_value;
		}

		/**
		 * @brief Returns a reference to the value
		 *
		 * @return A reference to the value
		 *
		 * @link https://en.cppreference.com/w/cpp/utility/optional/operator* @endlink
		 */
		constexpr const T &operator*() const & noexcept {
			return _value;
		}

		/**
		 * @brief Returns a reference to the value
		 *
		 * @return A reference to the value
		 *
		 * @link https://en.cppreference.com/w/cpp/utility/optional/operator* @endlink
		 */
		constexpr T &operator*() & noexcept {
			return _value;
		}

		/**
		 * @brief Returns a reference to the value
		 *
		 * @return A reference to the value
		 *
		 * @link https://en.cppreference.com/w/cpp/utility/optional/operator* @endlink
		 */
		constexpr const T &&operator*() const && noexcept {
			return forward<const T>(_value);
		}

		/**
		 * @brief Returns a reference to the value
		 *
		 * @return A reference to the value
		 *
		 * @link https://en.cppreference.com/w/cpp/utility/optional/operator* @endlink
		 */
		constexpr T &&operator*() && noexcept {
			return forward<T>(_value);
		}

		/**
		 * @brief Returns a reference to the value
		 *
		 * @return A reference to the value
		 *
		 * @link https://en.cppreference.com/w/cpp/utility/optional/value @endlink
		 */
		constexpr T &value() & {
			if (!_has_value) {
#ifdef __is_kernel
				// TODO change to kernel panic
				Debug::log_failure("optional::value() has no value");
				Debug::trace_stack();
				CPU::halt();
#else
				// TODO implement bad_optional_access
				throw bad_optional_access();
#endif
			}

			return _value;
		}

		/**
		 * @brief Returns a reference to the value
		 *
		 * @return A reference to the value
		 *
		 * @link https://en.cppreference.com/w/cpp/utility/optional/value @endlink
		 */
		constexpr const T &value() const & {
			if (!_has_value) {
#ifdef __is_kernel
				// TODO change to kernel panic
				Debug::log_failure("optional::value() has no value");
				Debug::trace_stack();
				CPU::halt();
#else
				// TODO implement bad_optional_access
				throw bad_optional_access();
#endif
			}

			return _value;
		}

		/**
		 * @brief Returns a reference to the value
		 *
		 * @return A reference to the value
		 *
		 * @link https://en.cppreference.com/w/cpp/utility/optional/value @endlink
		 */
		constexpr T &&value() && {
			if (!_has_value) {
#ifdef __is_kernel
				// TODO change to kernel panic
				Debug::log_failure("optional::value() has no value");
				Debug::trace_stack();
				CPU::halt();
#else
				// TODO implement bad_optional_access
				throw bad_optional_access();
#endif
			}

			return forward<T>(_value);
		}

		/**
		 * @brief Returns a reference to the value
		 *
		 * @return A reference to the value
		 *
		 * @link https://en.cppreference.com/w/cpp/utility/optional/value @endlink
		 */
		constexpr const T &&value() const && {
			if (!_has_value) {
#ifdef __is_kernel
				// TODO change to kernel panic
				Debug::log_failure("optional::value() has no value");
				Debug::trace_stack();
				CPU::halt();
#else
				// TODO implement bad_optional_access
				throw bad_optional_access();
#endif
			}

			return forward<T>(_value);
		}

		/**
		 * @brief Returns either a reference to the value or the default value
		 *
		 * @tparam U The type of the default value
		 * @param default_value The default value
		 * @return Either a reference to the value or the default value
		 *
		 * @link https://en.cppreference.com/w/cpp/utility/optional/value_or @endlink
		 */
		template <typename U>
		constexpr T value_or(U &&default_value) const & {
			if (_has_value) {
				return _value;
			}
			return forward<U>(default_value);
		}

		/**
		 * @brief Returns either a reference to the value or the default value
		 *
		 * @tparam U The type of the default value
		 * @param default_value The default value
		 * @return Either a reference to the value or the default value
		 *
		 * @link https://en.cppreference.com/w/cpp/utility/optional/value_or @endlink
		 */
		template <typename U>
		constexpr T value_or(U &&default_value) && {
			if (_has_value) {
				return move(_value);
			}
			return forward<U>(default_value);
		}

		// TODO monadic operations

		/**
		 * @brief Swaps the values of two optionals
		 *
		 * @param other The other optional
		 *
		 * @link https://en.cppreference.com/w/cpp/utility/optional/swap @endlink
		 */
		constexpr void swap(optional &other) noexcept(is_nothrow_move_constructible_v<T> &&is_nothrow_swappable_v<T>) {
			if (_has_value && other._has_value) {
				using std::swap;
				swap(**this, *other);
			} else if (_has_value) {
				new (&other._value) T(move(_value));
				_value.~T();
				other._has_value = true;
				_has_value = false;
			} else if (other._has_value) {
				new (&_value) T(move(other._value));
				other._value.~T();
				_has_value = true;
				other._has_value = false;
			}
		}
		// VERIFY noexcept is meaningless with exceptions disabled

		/**
		 * @brief Destroys the value if it exists
		 *
		 * @link https://en.cppreference.com/w/cpp/utility/optional/reset @endlink
		 */
		constexpr void reset() noexcept {
			if (_has_value) {
				_value.~T();
				_has_value = false;
			}
		}

		/**
		 * @brief Constructs the value in-place
		 *
		 * @tparam Args The types of the arguments to be passed to the constructor of T
		 * @param args The arguments to be passed to the constructor of T
		 * @return A reference to the value
		 */
		template <class... Args>
		constexpr T &emplace(Args &&...args) {
			if (_has_value) {
				_value.~T();
			}
			new (&_value) T(forward<Args>(args)...);
			_has_value = true;
			return _value;
		}

		/**
		 * @brief Constructs the value in-place
		 *
		 * @tparam U The type of the initializer list
		 * @tparam Args The types of the arguments to be passed to the constructor of T
		 * @param list The initializer list to be passed to the constructor of T
		 * @param args The arguments to be passed to the constructor of T
		 * @return A reference to the value
		 */
		template <class U, class... Args>
		constexpr T &emplace(std::initializer_list<U> ilist, Args &&...args)
			requires(is_constructible_v<T, std::initializer_list<U> &, Args && ...>)
		{
			if (_has_value) {
				_value.~T();
			}
			_value = T(ilist, forward<Args>(args)...);
			_has_value = true;
			return _value;
		}
	};

	// TODO comparison operators

	// TODO make_optional

	/**
	 * @brief Swaps the values of two optional objects
	 *
	 * @tparam T The type of the optional objects
	 * @param lhs The first optional object
	 * @param rhs The second optional object
	 *
	 * @endlink https://en.cppreference.com/w/cpp/utility/optional/swap2 @endlink
	 */
	template <typename T>
	constexpr void swap(optional<T> &lhs, optional<T> &rhs) noexcept(noexcept(lhs.swap(rhs)))
		requires(is_move_constructible_v<T> && is_swappable_v<T>)
	{
		lhs.swap(rhs);
	}
}