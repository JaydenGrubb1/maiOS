/**
 * @author Jayden Grubb (contact@jaydengrubb.com)
 * @date 2024-03-06
 * @brief Class template for referencing a contiguous sequence of objects
 *
 * Copyright (c) 2024, Jayden Grubb
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree.
 */

#pragma once

#define __need_size_t
#include <stddef.h>

#include <cstddef>
#include <type_traits>

#include <array>
#include <bits/reverse_iterator.h>
#include <cassert>
#include <optional>

namespace std {
	/**
	 * @brief A special value indicating that the extent of the sequence is unknown at compile time
	 *
	 */
	inline constexpr size_t dynamic_extent = static_cast<size_t>(-1);

	namespace __detail {
		template <size_t Extent>
		struct __extent_t {
		  public:
			constexpr __extent_t(size_t) {}

			static constexpr size_t __value() {
				return Extent;
			}
		};

		template <>
		struct __extent_t<dynamic_extent> {
		  private:
			size_t _value;

		  public:
			constexpr __extent_t(size_t size) : _value(size) {}

			constexpr size_t __value() const {
				return _value;
			}
		};
	}

	/**
	 * @brief Class template for referencing a contiguous sequence of objects
	 *
	 * @tparam T The type of the elements
	 * @tparam Extent The extent of the sequence
	 */
	template <class T, size_t Extent>
	class span;

	/**
	 * @brief Class template for referencing a contiguous sequence of objects
	 *
	 * @tparam T The type of the elements
	 * @tparam Extent The extent of the sequence
	 */
	template <class T, size_t Extent = dynamic_extent>
	class span {
	  private:
		T *_data;
		[[no_unique_address]] __detail::__extent_t<Extent> _extent;

		template <size_t Offset, size_t Count>
		static constexpr size_t __subspan_extent() {
			if constexpr (Count != dynamic_extent) {
				return Count;
			} else if constexpr (Extent != dynamic_extent) {
				return Extent - Offset;
			} else {
				return dynamic_extent;
			}
		}

	  public:
		static constexpr size_t extent = Extent;

#pragma region Constructors
		constexpr span()
			requires(Extent == dynamic_extent || Extent == 0)
			: _data(nullptr), _extent(0) {}

		template <typename It>
		constexpr explicit(extent != dynamic_extent) span(It first, size_t count)
			: _data(first), _extent(count) {}
		// TODO more trait constraints
		// TODO std::to_address(begin)
		// TODO range asserts

		template <typename It, typename End>
		constexpr explicit(extent != dynamic_extent) span(It first, End last)
			: _data(first), _extent(static_cast<size_t>(last - first)) {}
		// TODO more trait constraints
		// TODO std::to_address(begin)
		// TODO range asserts

		template <size_t N>
		constexpr span(std::type_identity_t<T> (&arr)[N])
			: _data(static_cast<T *>(arr)), _extent(N) {}
		// TODO more trait constraints

		template <typename U, size_t N>
		constexpr span(std::array<U, N> &arr)
			: _data(static_cast<T *>(arr.data())), _extent(N) {}
		// TODO more trait constraints

		template <typename U, size_t N>
		constexpr span(const std::array<U, N> &arr)
			: _data(static_cast<T *>(arr.data())), _extent(N) {}
		// TODO more trait constraints

		template <typename R>
		constexpr explicit(extent != dynamic_extent) span(R &&range)
			: _data(range.data()), _extent(range.size()) {}
		// TODO more trait constraints
		// TODO range::data and range::size
		// TODO extent asserts

		template <class U, size_t N>
		constexpr explicit(extent != dynamic_extent && N != dynamic_extent) span(const span<U, N> &other)
			requires(Extent == dynamic_extent || N == Extent)
			: _data(other.data()), _extent(other.size()) {}
		// TODO more trait constraints
		// TODO extent asserts

		constexpr span(const span &other) = default;
#pragma endregion

		~span() = default;

		constexpr span &operator=(const span &other) = default;

#pragma region Capacity Functions
		constexpr size_t size() const {
			return _extent.__value();
		}

		constexpr size_t size_bytes() const {
			return size() * sizeof(T);
		}

		constexpr bool empty() const {
			return size() == 0;
		}
#pragma endregion

#pragma region Accessor Functions
		constexpr T &operator[](size_t index) const {
			return _data[index];
		}

		constexpr optional<T> at(size_t index) {
			if (index >= size()) {
				return {};
			}
			return _data[index];
		}

		constexpr T &front() const {
			return _data[0];
		}

		constexpr T &back() const {
			return _data[size() - 1];
		}

		constexpr T *data() const {
			return _data;
		}
#pragma endregion

#pragma region Iterator Functions
		constexpr T *begin() const {
			return _data;
		}

		constexpr const T *cbegin() const {
			return _data;
		}

		constexpr T *end() const {
			return _data + size();
		}

		constexpr const T *cend() const {
			return _data + size();
		}

		constexpr std::reverse_iterator<T *> rbegin() const {
			return std::reverse_iterator<T *>(end());
		}

		constexpr const std::reverse_iterator<T *> crbegin() const {
			return std::reverse_iterator<T *>(cend());
		}

		constexpr std::reverse_iterator<T *> rend() const {
			return std::reverse_iterator<T *>(begin());
		}

		constexpr const std::reverse_iterator<T *> crend() const {
			return std::reverse_iterator<T *>(cbegin());
		}
#pragma endregion

#pragma region Subspan Functions
		template <size_t Count>
		constexpr span<T, Count> first() const {
			if constexpr (Extent == dynamic_extent) {
				assert(Count <= size());
			} else {
				static_assert(Count <= extent);
			}
			return span<T, Count>{data(), Count};
		}

		constexpr span<T, dynamic_extent> first(size_t count) const {
			assert(count <= size());
			return {data(), count};
		}

		template <size_t Count>
		constexpr span<T, Count> last() const {
			if constexpr (Extent == dynamic_extent) {
				assert(Count <= size());
			} else {
				static_assert(Count <= extent);
			}
			return span<T, Count>{data() + size() - Count, Count};
		}

		constexpr span<T, dynamic_extent> last(size_t count) const {
			assert(count <= size());
			return {data() + size() - count, count};
		}

		template <size_t Offset, size_t Count = dynamic_extent>
		constexpr span<T, __subspan_extent<Offset, Count>()> subspan() const {
			if constexpr (Extent == dynamic_extent) {
				assert(Offset <= size());
			} else {
				static_assert(Offset <= extent);
			}

			if constexpr (Count == dynamic_extent) {
				return span<T, __subspan_extent<Offset, Count>()>{data() + Offset, size() - Offset};
			} else {
				if constexpr (Extent == dynamic_extent) {
					assert(Count <= size() - Offset);
				} else {
					static_assert(Count <= extent - Offset);
				}
				return span<T, __subspan_extent<Offset, Count>()>{data() + Offset, Count};
			}
		}

		constexpr span<T, dynamic_extent> subspan(size_t offset, size_t count = dynamic_extent) const {
			assert(offset <= size());
			if (count == dynamic_extent) {
				return {data() + offset, size() - offset};
			} else {
				assert(count <= size() - offset);
				return {data() + offset, count};
			}
		}
#pragma endregion
	};

	// Deduction guides
	// https://en.cppreference.com/w/cpp/container/span/deduction_guides

	// template <typename It, typename End>
	// span(It, End) -> span<std::remove_reference_t<std::iter_reference_t<It>>>;
	// TODO requires std::iter_reference_t

	template <typename T, size_t N>
	span(T (&)[N]) -> span<T, N>;

	template <typename T, size_t N>
	span(array<T, N> &) -> span<T, N>;

	template <typename T, size_t N>
	span(const array<T, N> &) -> span<const T, N>;

	// template <typename R>
	// span(R &&) -> span<std::remove_reference_t<std::ranges::range_reference_t<R>>>;
	// TODO requires std::ranges::range_reference_t

	template <typename T, size_t N>
	span<const byte, N == dynamic_extent ? dynamic_extent : N * sizeof(T)> as_bytes(span<T, N> sp) {
		auto data = reinterpret_cast<const byte *>(sp.data());
		auto size = sp.size_bytes();
		constexpr size_t extent = N == dynamic_extent ? dynamic_extent : N * sizeof(T);
		return span<const byte, extent>{data, size};
	}

	template <typename T, size_t N>
	span<byte, N == dynamic_extent ? dynamic_extent : N * sizeof(T)> as_writable_bytes(span<T, N> sp)
		requires(!std::is_const_v<T>)
	{
		auto data = reinterpret_cast<byte *>(sp.data());
		auto size = sp.size_bytes();
		constexpr size_t extent = N == dynamic_extent ? dynamic_extent : N * sizeof(T);
		return span<byte, extent>{data, size};
	}
}